import os
import sys
import time
import json
import uuid
import time
import errno
import bblfsh
import base64
import pathlib
import resource
import datetime
from subprocess import PIPE, Popen
from contextlib import contextmanager
from threading import Timer


PROCESS_MAP = {}

PARSER_MAP = {
  # 'Shell': (
  #   'localhost:9432', 'bash'),
  'Go': (
    'localhost:9433', 'go'),
  'Java': (
    'localhost:9434', 'java'),
  'JavaScript': (
    'localhost:9435', 'javascript'),
  'PHP': (
    'localhost:9436', 'php'),
  'Python': (
    'localhost:9437', 'python'),
  'Ruby': (
    'localhost:9438', 'ruby'),
  'TypeScript': (
    'localhost:9439', 'typescript'),
  'C': (
    'localhost:9440', 'c'),
  'C++': (
    'localhost:9441', 'cpp')
}


@contextmanager
def symlinks(links):
  for target, link in links:
    try:
      os.symlink(target, link)
    except OSError as e:
      if e.errno == errno.EEXIST:
        os.remove(link)
        os.symlink(target, link)
      else:
        raise e
  yield
  for _, link in links:
    os.remove(link)

def setlimits():
    resource.setrlimit(resource.RLIMIT_RSS, (1024*1024*1024*3, 1024*1024*1024*3))

def recycle_parser(name):
  namea = name
  nameb = PARSER_MAP[namea][1] if namea != 'C' else 'cpp'

  # print(namea + '::' + nameb, file=sys.stderr)

  if namea in PROCESS_MAP:
    PROCESS_MAP[namea].kill()
    time.sleep(5)

  DRIVER_SYM_LINKS = [
    ( '/opt/drivers/{}'.format(nameb), '/opt/driver' )
  ]

  with symlinks(DRIVER_SYM_LINKS):
    PROCESS_MAP[namea] = Popen([
      '/opt/drivers/{}/bin/driver'.format(nameb),
      '--address',
      PARSER_MAP[namea][0],
      '--log-level',
      'warn'
    ], preexec_fn=setlimits)

    # Fixed delay while we wait for driver to become ready
    time.sleep(3)


# Load data from stdin (generated by enry)
enry_data = json.load(sys.stdin)

# Now add in UASTs
for supported_lang in PARSER_MAP.keys():
  if supported_lang in enry_data:
    for src_file in enry_data[supported_lang]:
      # Start timing parse
      parse_start_time = datetime.datetime.now()

      # Generate a UUID to use 
      uid = str(uuid.uuid5(
        uuid.NAMESPACE_URL,
        "https://{}/{}?at={}&branch={}".format(
          sys.argv[1],
          src_file,
          sys.argv[3],
          sys.argv[2]
        )
      ))

      # Args for popen
      pargs = [
        "bblfsh-cli", 
        "-a", 
        PARSER_MAP[supported_lang][0],
        "-l",
        PARSER_MAP[supported_lang][1],
        '-m',
        'native',
        "--v2",
        './{}'.format(src_file)
      ]

      print(' '.join(pargs), file=sys.stderr)

      # Recycle parser
      try:
        recycle_parser(supported_lang)
      except Exception as ex:
        print('Failed to recycle parser', file=sys.stderr)
        print(ex, file=sys.stderr)

      # Invoke bblfsh-cli (and handle possible failures)
      UAST = {}
      GOOD_PARSE = False
      info = {}
      try:
        # Do popen
        with Popen(pargs, stdout=PIPE, stderr=PIPE, universal_newlines=True, preexec_fn=setlimits) as proc:
          # Control process via timer (sixty second timeout)
          timer = Timer(60, proc.kill)
          timer.start()

          response, errs = proc.communicate()
  
          if errs is not None and len(errs) > 0:
            info['errors'] = errs
          info['response'] = response
  
          # Get the json
          as_json = json.loads(response)
          GOOD_PARSE = True
  
          # Reformat and encode
          UAST = json.dumps(as_json).encode('utf-8')
      except Exception as ex:
        # For exceptions just note the issues
        as_json = {}
        as_json['error'] = str(ex)
        as_json['details'] = info
        GOOD_PARSE = False
        UAST = json.dumps(as_json).encode('utf-8')
      finally:
          timer.cancel()

      # Save elapsed time (for parse)
      parse_elapsed_time = datetime.datetime.now() - parse_start_time

      # Stream this data out to stdout right away
      print('{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}\t{}'.format(
        uid,
        src_file,
        pathlib.Path(src_file).name,
        supported_lang,
        datetime.datetime.now().isoformat(),
        sys.argv[1],
        sys.argv[2],
        sys.argv[3],
        '{:.3f}'.format(
          parse_elapsed_time.total_seconds() * 1000),
        'YES' if GOOD_PARSE else 'NO',
        base64.b64encode(UAST).decode('utf-8')
      ))

      del UAST
      del info
      del as_json


for k,v in PROCESS_MAP.items():
  try:
    v.kill()
  except Exception as ex:
    pass
