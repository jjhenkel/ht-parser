import sys
import time
import json
import uuid
import bblfsh
import pathlib
import datetime
from google.protobuf.json_format import MessageToDict


# Helper func adapted from:
# https://github.com/src-d/ml/blob/b427393becdca66e04cd4c7ac3d5b80266e1cecb
#   /sourced/ml/transformers/moder.py#L84
def extract_functions_from_uast(uast):
  FUNC_XPATH = "//*[@roleFunction and @roleDeclaration]"
  FUNC_NAME_XPATH = "/*[@roleFunction and @roleIdentifier and @roleName] " \
                      "| /*/*[@roleFunction and @roleIdentifier and @roleName]"

  all_funcs = list(bblfsh.filter(uast, FUNC_XPATH))
  internal = set()

  for func in all_funcs:
    if id(func) in internal:
      continue

    sub_seq = bblfsh.filter(func, FUNC_XPATH)

    for sub in sub_seq:
      if sub != func:
        internal.add(id(sub))

  for f in all_funcs:
    if id(f) not in internal:
      f_seq = bblfsh.filter(f, FUNC_NAME_XPATH)
      name = "+".join(n.token for n in f_seq)
      if name:
        yield f, name


# Start timing
start_time = time.time()

# PARSER_MAP : maps from lang to parsers
PARSER_MAP = {
  'Shell': (
    bblfsh.BblfshClient('unix:///tmp/bash'), 'bash'),
  'Go': (
    bblfsh.BblfshClient('unix:///tmp/go'), 'go'),
  'Java': (
    bblfsh.BblfshClient('unix:///tmp/java'), 'java'),
  'JavaScript': (
    bblfsh.BblfshClient('unix:///tmp/javascript'), 'javascript'),
  'PHP': (
    bblfsh.BblfshClient('unix:///tmp/php'), 'php'),
  'Python': (
    bblfsh.BblfshClient('unix:///tmp/python'), 'python'),
  'Ruby': (
    bblfsh.BblfshClient('unix:///tmp/ruby'), 'ruby'),
  'TypeScript': (
    bblfsh.BblfshClient('unix:///tmp/typescript'), 'typescript')
}

# Load data from stdin (generated by enry)
enry_data = json.load(sys.stdin)

# All of the info for this repository
repo = {
  'url': sys.argv[1],
  'branch': sys.argv[2],
  'commit': sys.argv[3],
  'generated_at': datetime.datetime.now().isoformat(),
  'files': {},
  'uasts': {}
}

# Build some scaffolding
for lang in enry_data.keys():
  repo['files'][lang] = enry_data[lang]
  if lang in PARSER_MAP.keys():
    repo['uasts'][lang] = {}

# Now add in UASTs
for supported_lang in PARSER_MAP.keys():
  if supported_lang in enry_data:
    for src_file in enry_data[supported_lang]:
      # Start timing parse
      parse_start_time = time.time()

      # Generate a UUID to use 
      uid = str(uuid.uuid5(
        uuid.NAMESPACE_URL,
        "https://{}/{}?at={}&branch={}".format(
          sys.argv[1],
          src_file,
          sys.argv[3],
          sys.argv[2]
        )
      ))

      # Holds the data we are going to save for this file
      file_data = {
        'uuid': uid,
        'file_name': pathlib.Path(src_file).name,
        'file_path': src_file,
        'file_lang': supported_lang,
        'generated_at': datetime.datetime.now().isoformat(),
        'functions': {},
        'full_uast': {},
        'repo_url': sys.argv[1],
        'repo_branch': sys.argv[2],
        'repo_commit': sys.argv[3]
      }

      # IDX used to make sure we get unique function names in a file
      # (for many reasons, there is a chance we do NOT get unique names)
      idx = 0

      # Need to write this to disk right away (to avoid ending up
      # keeping GBs of UASTs in memory before a final write)
      UAST = PARSER_MAP[supported_lang][0].parse(
        './{}'.format(src_file), 
        language=PARSER_MAP[supported_lang][1]
      ).uast

      # Go through and save all of the functions individually (as this is
      # a major usecase)
      for func, name in extract_functions_from_uast(UAST):
        idx += 1
        file_data['functions']['{}#{}'.format(name, idx)] = MessageToDict(func)


      # Save UAST in full
      file_data['full_uast'] = MessageToDict(UAST)

      # Save elapsed time (for parse)
      parse_elapsed_time = time.time() - parse_start_time
      file_data['elapsed_time'] = time.strftime(
        "%H:%M:%S", time.gmtime(parse_elapsed_time)
      )

      # Save UAST to disk
      with open('./repository-uasts/{}.json'.format(uid), 'w') as outf:
        json.dump(
          file_data, outf, ensure_ascii=False, indent=2, sort_keys=True)

      # Give a pointer to the UAST instead of actual full object
      repo['uasts'][supported_lang][src_file] = \
        'repository-uasts/{}.json'.format(uid)

# Save elapsed time
elapsed_time = time.time() - start_time
repo['elapsed_time'] = time.strftime("%H:%M:%S", time.gmtime(elapsed_time))

# Save the data
with open('./repository.json', 'w') as outf:
  json.dump(repo, outf, ensure_ascii=False, indent=2, sort_keys=True)
